## 1. 把数组中的 0 移到末尾
283. Move Zeroes (Easy)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例：
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

### 思路
- 我们创建两个指针i和j，第一次遍历的时候指针j用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。
- 第二次遍历的时候，起始位置就从j开始到结束，将剩下的这段区域内的元素全部置为0。

### 代码
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i = 0
        j = 0
        while i < len(nums):
            if nums[i] != 0:
                nums[j] = nums[i]
                j += 1
            i += 1
        while j < len(nums):
            nums[j] = 0
            j += 1
        return nums 
```
- 时间复杂度:O(n)
- 空间复杂度:O(1)

## 2. 改变矩阵维度
566. Reshape the Matrix (Easy)

在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵.

示例1：
```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
```

示例2：
```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
```
注意：
- 给定矩阵的宽和高范围在 [1, 100]。
- 给定的 r 和 c 都是正数。

### 思路
- 将矩阵转换为数组，再根据目标矩阵的列数进行切片。

### 代码
```
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(nums) * len(nums[0]) != r * c:
            return nums
        else:
            origin = []
            for i in range(len(nums)):
                origin += nums[i]
            res = []
            for i in range(r):
                res.append(origin[i*c:i*c+c])
            return res
```
- 时间复杂度：O(m∗n)。我们只遍历整个矩阵 m∗n。这里，m 和 n 指的是给定矩阵中的行数和列数。

- 空间复杂度：O(m∗n)。使用大小为 m∗n 的结果矩阵。

## 3. 找出数组中最长的连续 1
485. Max Consecutive Ones (Easy)

给定一个二进制数组， 计算其中最大连续1的个数。

示例：
```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```
输入的数组只包含 0 和1。
输入数组的长度是正整数，且不超过 10,000。

### 思路
- 计数器 sum 初始化为 0，记录 1 的个数。遇到 1 加 1，遇到 0 重置为 0。
- 另一个计数器 maxsum 记录当前最大的 1 的个数。
- 返回maxsum。

### 代码
```
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        sum = 0
        maxsum = 0
        for num in nums:
            if num == 1:
                sum += 1
            else:
                maxsum = max(sum, maxsum)
                sum = 0
        #若都为1，则 sum 比 maxsum 大
        return max(sum, maxsum)
```
- 时间复杂度：O(N)。N 值得是数组的长度。
- 空间复杂度：O(1)，仅仅使用了 count 和 maxCount。
  
## 4. 有序矩阵查找
240. Search a 2D Matrix II (Medium)

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

示例:

现有矩阵 matrix 如下：
```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
给定 target = 5，返回 true。

给定 target = 20，返回 false。

### 思路
- 可以用双指针进行查找
1.  两个指针开始指向左下角 row = len(matrix) - 1, col = 0
2.  若当前值小于目标值，向右寻找，col += 1, 若当前值大于目标值，向上寻找。row  -= 1。
3. 找到目标值，返回True，结束循环后(row  >= 0 and col < len(matrix))未找到目标值，返回Fasle。

### 代码
```
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if (len(matrix) == 0) or (len(matrix[0]) == 0):
            return False
        height = len(matrix)
        width = len(matrix[0])
        row = height - 1
        col = 0
        while (row >= 0) and (col < width):
            if matrix[row][col] > target:
                row -= 1
            elif matrix[row][col] < target:
                col += 1
            else:
                return True
        return False
```
- 时间复杂度：O(n+m)。
时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少 m 次，而列只能增加 n 次，因此在导致 while 循环终止之前，循环不能运行超过 n+m 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。
- 空间复杂度：O(1)，因为这种方法只处理几个指针，所以它的内存占用是恒定的。

## 5. 有序矩阵的 Kth Element
378. Kth Smallest Element in a Sorted Matrix ((Medium))

定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

示例：
```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```
提示：
你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。
### 思路
此题可以用二分查找，但不是主流解法
- 矩阵中小于等于一个数的的元素必定在其左上方。我们可以统计小于等于指定值的个数。
- 设置两个针指指向左下角，i = len(matrix) - 1, j = 0。若当前值小于指定值，说明此列中当前值及上方数值均小于指定值，用 num = num + i + 1 记录。并且指针右移，j += 1。若当前值大于指定值，指针上移，i -= 1。返回值为num >= K
- 二分查找的左边界为左上角，有边界为右上角。判断条件为小于等于中间值的个数是否大于等于K，若成立，向左寻找，否则向右寻找。

### 代码
```
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)

        def check(mid):
            row = n - 1
            col = 0
            num = 0
            while row >= 0 and col < n:
                if matrix[row][col] <= mid:
                    num = num + row + 1
                    col += 1
                else:
                    row -= 1
            return num >= k
        l = matrix[0][0]
        r = matrix[-1][-1]
        while l < r:
            mid = (l + r) // 2
            if check(mid):
                r = mid
            else:
                l = mid + 1
        return l
```
- 时间复杂度：O(nlog(r−l))，二分查找进行次数为 O(log(r−l))，每次操作时间复杂度为 O(n)。

- 空间复杂度：O(1)。



