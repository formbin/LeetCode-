# 递归
一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。

## 递归三部曲
1. 找整个递归的终止条件：递归应该在什么时候结束？
2. 找返回值：应该给上一级返回什么信息？
3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？
- 不必纠结这一层函数做了什么，下一层函数做了什么，只需关注一级递归的解决过程即可。
## 1. 树的高度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。
### 思路
力扣官方题解 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/
### 代码
```
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1 
```
复杂度分析

- 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)O(N)，
其中 NN 是结点的数量。
- 空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 NN 次（树的高度），因此保持调用栈的存储将是 O(N)O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 \log(N)log(N)。因此，在这种情况下的空间复杂度将是 O(\log(N))O(log(N))。
## 2. 平衡树
110. Balanced Binary Tree (Easy)
    
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回true

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]
```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回false
### 思路
从底至顶（提前阻断）
此方法为本题的最优解法，但“从底至顶”的思路不易第一时间想到。

思路是对二叉树做先序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。

从顶至底（暴力法）
此方法容易想到，但会产生大量重复计算，时间复杂度较高。
### 算法流程
isBalanced(root) ：判断树 root 是否平衡
- 特例处理： 若树根节点 root 为空，则直接返回 true；
- 返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑&& 连接；
### 复杂度分析
- 时间复杂度 O(Nlog2 N)： 最差情况下，isBalanced(root) 遍历树所有节点，占用 O(N)；判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点，子树的节点数的复杂度为O(log2 N)。
- 空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。
### 暴力法代码
```
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        return abs(self.height(root.left) - self.height(root.right)) < 2 \
            and self.isBalanced(root.left) \
            and self.isBalanced(root.right)
    def height(self, root: TreeNode) -> int:
        if not root:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))
```
# 3. 两节点的最长路径
543. 二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树
```
          1
         / \
        2   3
       / \     
      4   5   
```
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
## 思路
- 重点是任意一个结点，都要记录以此结点为根的直径情况：左子树高度+右子树高度
- 需要一个值来保存我这个每次比较更新的最大直径值，用self.ans = 1来初始化这个值
- 在每次获得一个节点的左子树和右子树的值的时候，都需要比较一下self.ans和左子树高度+右子树高度的大小减1，把更大的保存下来
###代码
```
    self.ans = 1
    def depth(node):
        if not node:
            # 访问到空节点了，返回0
            return 0
            # 左儿子为根的子树的深度
        L = depth(node.left)
        # 右儿子为根的子树的深度
        R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
        self.ans = max(self.ans, L + R + 1)
        # 返回该节点为根的子树的深度
        return max(L, R) + 1
    depth(root)
    return self.ans -1
```
# 4.翻转树
1.   翻转二叉树

示例：

输入：
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
输出：
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
## 思路
- 终止条件：节点为空
- 返回值：当前节点以及它的左右子树
- 本级递归：交换左右子树
  
题解：https://leetcode-cn.com/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/

代码
```
class Solution(object):
    def invertTree(self, root):
    #函数递归终止条件，节点为空时返回
        if not root:
            return None:
        # 将当前节点的左右子树交换
        root.left, root.right = root.right, root.left
        # 递归交换当前节点的 左子树和右子树
        self.invertTree(root.left)
        self.invertTree(root.right)
        # 函数返回时就表示当前这个节点，以及它的左右子树
		# 都已经交换完了
        retrun root
```
- 时间复杂度：每个元素都必须访问一次，所以是O(n)
- 空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)
# 5. 归并两棵树
1.   合并二叉树


给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例：
```
输入: 
	Tree 1                     Tree 2                  
          1                         2                 
         / \                       / \    
        3   2                     1   3
       /                           \   \
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```
## 思路
题解：https://leetcode-cn.com/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/
- 终止条件：树1的节点为null，或者树2的节点为null
- 返回值：t1, t2
- 本级递归：r1 + r2
### 代码
```
class Solution(object):
	def mergeTrees(self, t1, t2):
        def dfs(r1, r2):
        # 如果 r1和r2中，只要有一个是null，函数就直接返回
            if not (r1 and r2):
                return r1 if r1 else r2
            # 让r1的值 等于  r1和r2的值累加
			# 再递归的计算两颗树的左节点、右节点
            r1.val += r2.val
            r1.left = dfs(r1.left, r2.left)
            r1.right = dfs(r1.right, r2.right)
            return r1
        return dfs(t1, t2)
```
- 时间复杂度：O(N)，其中 N 是两棵树中节点个数的较小值。
- 空间复杂度：O(N)，在最坏情况下，会递归 N 层，需要 O(N) 的栈空间。

