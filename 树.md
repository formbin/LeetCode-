<!-- TOC -->autoauto- [递归xx](#递归xx)auto    - [递归三部曲](#递归三部曲)auto    - [1. 树的高度](#1-树的高度)auto        - [思路](#思路)auto        - [代码](#代码)auto    - [2. 平衡树](#2-平衡树)auto        - [思路](#思路-1)auto        - [算法流程](#算法流程)auto        - [复杂度分析](#复杂度分析)auto        - [暴力法代码](#暴力法代码)auto- [3. 两节点的最长路径](#3-两节点的最长路径)auto    - [思路](#思路-2)auto        - [代码](#代码-1)auto- [4.翻转树](#4翻转树)auto    - [思路](#思路-3)auto- [5. 归并两棵树](#5-归并两棵树)auto    - [思路](#思路-4)auto        - [代码](#代码-2)auto- [6. 判断路径和是否等于一个数](#6-判断路径和是否等于一个数)auto    - [思路](#思路-5)auto        - [代码](#代码-3)auto- [7. 统计路径和等于一个数的路径数量](#7-统计路径和等于一个数的路径数量)auto    - [思路](#思路-6)auto        - [代码 不懂](#代码-不懂)auto- [8.子树](#8子树)auto    - [解题思路](#解题思路)auto        - [代码](#代码-4)auto- [9. 树的对称](#9-树的对称)auto    - [思路](#思路-7)auto        - [代码](#代码-5)auto- [10. 最小路径](#10-最小路径)auto    - [思路](#思路-8)auto        - [代码](#代码-6)auto- [11. 统计左叶子节点的和](#11-统计左叶子节点的和)auto    - [思路](#思路-9)auto        - [代码](#代码-7)auto- [12. 相同节点值的最大路径长度](#12-相同节点值的最大路径长度)auto    - [思路](#思路-10)auto        - [代码](#代码-8)auto- [13. 间隔遍历](#13-间隔遍历)auto    - [思路 待解决 动态规划](#思路-待解决-动态规划)auto        - [代码](#代码-9)auto        - [动态+递归](#动态递归)auto- [14. 找出二叉树中第二小的节点](#14-找出二叉树中第二小的节点)auto    - [思路](#思路-11)auto        - [代码](#代码-10)autoauto<!-- /TOC -->
# 递归xx
- 干货：https://lyl0724.github.io/2020/01/25/1/#%E4%B8%80%E4%BA%9B%E5%8F%AF%E4%BB%A5%E7%94%A8%E8%BF%99%E4%B8%AA%E5%A5%97%E8%B7%AF%E8%A7%A3%E5%86%B3%E7%9A%84%E9%A2%98
  
一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。

## 递归三部曲
1. 找整个递归的终止条件：递归应该在什么时候结束？
2. 找返回值：应该给上一级返回什么信息？
3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？
- 不必纠结这一层函数做了什么，下一层函数做了什么，只需关注一级递归的解决过程即可。
## 1. 树的高度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。
### 思路
力扣官方题解 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/
### 代码
```
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1 
```
复杂度分析

- 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，
其中 N 是结点的数量。
- 空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 NN 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。
## 2. 平衡树
110. Balanced Binary Tree (Easy)
    
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回true

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]
```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回false
### 思路
从底至顶（提前阻断）
此方法为本题的最优解法，但“从底至顶”的思路不易第一时间想到。

思路是对二叉树做先序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。

从顶至底（暴力法）
此方法容易想到，但会产生大量重复计算，时间复杂度较高。
### 算法流程
isBalanced(root) ：判断树 root 是否平衡
- 特例处理： 若树根节点 root 为空，则直接返回 true；
- 返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑&& 连接；
### 复杂度分析
- 时间复杂度 O(Nlog2 N)： 最差情况下，isBalanced(root) 遍历树所有节点，占用 O(N)；判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点，子树的节点数的复杂度为O(log2 N)。
- 空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。
### 暴力法代码
```
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        return abs(self.height(root.left) - self.height(root.right)) < 2 \
            and self.isBalanced(root.left) \
            and self.isBalanced(root.right)
    def height(self, root: TreeNode) -> int:
        if not root:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))
```
# 3. 两节点的最长路径
543. 二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树
```
          1
         / \
        2   3
       / \     
      4   5   
```
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
## 思路
- 重点是任意一个结点，都要记录以此结点为根的直径情况：左子树高度+右子树高度
- 需要一个值来保存我这个每次比较更新的最大直径值，用self.ans = 1来初始化这个值
- 在每次获得一个节点的左子树和右子树的值的时候，都需要比较一下self.ans和左子树高度+右子树高度的大小减1，把更大的保存下来
### 代码
```
    self.ans = 1
    def depth(node):
        if not node:
            # 访问到空节点了，返回0
            return 0
            # 左儿子为根的子树的深度
        L = depth(node.left)
        # 右儿子为根的子树的深度
        R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
        self.ans = max(self.ans, L + R + 1)
        # 返回该节点为根的子树的深度
        return max(L, R) + 1
    depth(root)
    return self.ans -1
```
# 4.翻转树
226. Invert Binary Tree (Easy)

示例：

输入：
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
输出：
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
## 思路
- 终止条件：节点为空
- 返回值：当前节点以及它的左右子树
- 本级递归：交换左右子树
  
题解：https://leetcode-cn.com/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/

代码
```
class Solution(object):
    def invertTree(self, root):
    #函数递归终止条件，节点为空时返回
        if not root:
            return None:
        # 将当前节点的左右子树交换
        root.left, root.right = root.right, root.left
        # 递归交换当前节点的 左子树和右子树
        self.invertTree(root.left)
        self.invertTree(root.right)
        # 函数返回时就表示当前这个节点，以及它的左右子树
		# 都已经交换完了
        retrun root
```
- 时间复杂度：每个元素都必须访问一次，所以是O(n)
- 空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)
# 5. 归并两棵树
617. Merge Two Binary Trees (Easy)


给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例：
```
输入: 
	Tree 1                     Tree 2                  
          1                         2                 
         / \                       / \    
        3   2                     1   3
       /                           \   \
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```
## 思路
题解：https://leetcode-cn.com/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/
- 终止条件：树1的节点为null，或者树2的节点为null
- 返回值：t1, t2
- 本级递归：r1 + r2
### 代码
```
class Solution(object):
	def mergeTrees(self, t1, t2):
        def dfs(r1, r2):
        # 如果 r1和r2中，只要有一个是null，函数就直接返回
            if not (r1 and r2):
                return r1 if r1 else r2
            # 让r1的值 等于  r1和r2的值累加
            # 再递归的计算两颗树的左节点、右节点
            r1.val += r2.val
            r1.left = dfs(r1.left, r2.left)
            r1.right = dfs(r1.right, r2.right)
            return r1
        return dfs(t1, t2)
```
- 时间复杂度：O(N)，其中 N 是两棵树中节点个数的较小值。
- 空间复杂度：O(N)，在最坏情况下，会递归 N 层，需要 O(N) 的栈空间。
  

# 6. 判断路径和是否等于一个数
Leetcdoe : 112. Path Sum (Easy)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
## 思路
- 终止条件：到达叶子节点
- 返回值：True或者False
- 本级递归：sum - 当前节点权值，判断是否为0
### 代码
```
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        #sum减去当前节点的值
        sum -= root.val
        #若到达叶子节点判断sum是否为0
        if not root.left and not root.right:
            return sum == 0
        #递归调用函数
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)
```
- 时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。
- 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。
# 7. 统计路径和等于一个数的路径数量
437. Path Sum III (Easy)
    
给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

示例
```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```
## 思路
- 终止条件：节点为空
- 返回值：路径数目
- 本级递归：求路径的和
- 题解：https://leetcode-cn.com/problems/path-sum-iii/solution/hot-100-437lu-jing-zong-he-iii-python3-li-jie-di-g/
### 代码 不懂
```
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        prefixSumTree = {0:1}
        self.count = 0
        prefixSum = 0
        # 每次递归都会返回以当前节点为根的子树中的有效路径总数。这笔款项可分为三部分：
        # 以当前节点的左侧子节点为根的子树中的有效路径总数
        # 以当前节点的右侧子节点为根的子树中的有效路径总数
        # 当前节点结束的有效路径数量
        self.dfs(root, sum, prefixSum, prefixSumTree)
        return self.count
    def dfs(self,root, sum, prefixSum, prefixSumTree):
        if not root:
            return 0
        prefixSum += root.val
        #在向下遍历的过程中，判断上面是否存在sum == prefixSum -sum，而sum的记录存放在
        #prefixSumTree中
        oldSum = prefixSum - sum
        if oldSum in prefixSumTree:
            self.count += prefixSumTree[oldSum]
        prefixSumTree[prefixSum] = prefixSumTree.get(prefixSum, 0) + 1
        self.dfs(root.left, sum, prefixSum, prefixSumTree)
        self.dfs(root.right, sum, prefixSum, prefixSumTree)
        #一定要注意在递归回到上一层的时候要把当前层的prefixSum的个数-1，类似回溯，要把条件重置
        prefixSumTree[prefixSum] -= 1
```
# 8.子树
572. Subtree of Another Tree (Easy)
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:
```
     3
    / \
   4   5
  / \
 1   2
```
给定的树 t：
```
   4 
  / \
 1   2
```
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：
```
     3
    / \
   4   5
  / \
 1   2
    /
   0
```
给定的树 t：
```
   4
  / \
 1   2
```
返回 false。
## 解题思路
- 终止条件：
- 返回值：True或者False
- 本级递归:t是否和树s的任意子树相等
- 题解：https://leetcode-cn.com/problems/subtree-of-another-tree/solution/dui-cheng-mei-pan-duan-zi-shu-vs-pan-duan-xiang-de/
 
要判断一个树 t 是不是树 s 的子树，那么可以判断 t 是否和树 s 的任意子树相等。那么就转化成 100. Same Tree。
即，这个题的做法就是在 s 的每个子节点上，判断该子节点是否和 t 相等。

判断两个树是否相等的三个条件是与的关系，即：

1. 当前两个树的根节点值相等；
2. 并且，s 的左子树和 t 的左子树相等；
3. 并且，s 的右子树和 t 的右子树相等。

而判断 t 是否为 s 的子树的三个条件是或的关系，即：

1. 当前两棵树相等；
2. 或者，t 是 s 的左子树；
3. 或者，t 是 s 的右子树。

### 代码
```
class Solution(object):
    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s and not t:
            return True
        if not s or not t:
            return False
        #判断s是否和t相等或者s的左子树和t相等或者s的右子树和t相等
        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
        
    def isSameTree(self, s, t):
        if not s and not t:
            return True
        if not s or not t:
            return False
        #节点的值要相等
        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)
```
# 9. 树的对称
101. Symmetric Tree (Easy)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```
## 思路
- 终止条件：两个节点都为空，或者两个节点中有一个为空，或者两个节点的值不相等。
- 返回值：True或者False
- 本级递归：比较 left 的左节点和 right 的右节点，再比较 left 的右节点和 right 的左节点
- 题解：https://leetcode-cn.com/problems/symmetric-tree/solution/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/

### 代码
```
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        def dfs(left, right):
            # 递归的终止条件是两个节点都为空
            # 或者两个节点中有一个为空
            # 或者两个节点的值不相等
            if left is None and right is None:
                return True
            if not(left and right):
                return False
            if left.val != right.val:
                return False
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        # 用递归函数，比较左节点，右节点
        return dfs(root.left, root.right)
```
- 算法的时间复杂度是 O(n)，因为要遍历 n 个节点
- 空间复杂度是 O(n)，空间复杂度是递归的深度，也就是跟树高度有关，最坏情况下树变成一个链表结构，高度是n。
# 10. 最小路径
111. Minimum Depth of Binary Tree (Easy)
     
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最小深度  2
## 思路
递归条件
- 叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点
- 当 root 节点左右孩子都为空时，返回 1
- 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
- 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值
  
### 代码
```
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        children = [root.left, root.right]
        #如果到达叶子节点
        if not any(children):
            return 1
        
        #min_depth初始化为正无穷
        min_depth = float('inf')
        for c in children:
            if c:
                min_depth = min(self.minDepth(c), min_depth)
        return min_depth + 1
```
- 时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。
- 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N))。

# 11. 统计左叶子节点的和
404. Sum of Left Leaves (Easy)

计算给定二叉树的所有左叶子之和。
```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```
## 思路
- 终止条件：节点为空
- 返回值：整数
- 本级递归：左节点累加
- 题解：https://leetcode-cn.com/problems/sum-of-left-leaves/solution/python3de-di-gui-he-die-dai-jie-fa-by-lian-xi-shi-/

首先需要遍历整个二叉树，在遍历的过程中确定左叶子，并求和。
遍历方法有深度优先遍历(前序，中序，后序），不太推荐广度优先遍历(层序遍历)。

然后考虑满足左叶子的条件：1.首先该节点不能有左右孩子节点。2.该节点是父节点的左孩子。两个条件即可满足所有判断条件。
### 代码
```
###方法二：前序遍历递归解法：
        self.res=0
        def helper(root):
            if not root:return 0
            if root.left and not root.left.left and not root.left.right:
                self.res+=root.left.val
            helper(root.left)
            helper(root.right)
        temp=root
        helper(temp)
        return self.res
```
# 12. 相同节点值的最大路径长度
687. Longest Univalue Path (Easy)

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

输入
```
              5
             / \
            4   5
           / \   \
          1   1   5
```
输出
```
2
```
输入
```
              1
             / \
            4   5
           / \   \
          4   4   5

```
输出 2
## 思路
- 终止条件：节点为空
- 返回值：左子树相同节点路径长度加右子树节点路径长度的最大值
- 本级递归：遍历树，左子树节点与根节点值相同，路径长度加1，右子树亦然。
- 题解：https://leetcode-cn.com/problems/longest-univalue-path/solution/zui-chang-tong-zhi-lu-jing-by-leetcode/
### 代码
```
class Solution(object):
    def longestUnivaluePath(self, root):
        self.ans = 0

        def arrow_length(node):
            if not node: return 0
            left_length = arrow_length(node.left)
            right_length = arrow_length(node.right)
            left_arrow = right_arrow = 0
            if node.left and node.left.val == node.val:
                left_arrow = left_length + 1
            if node.right and node.right.val == node.val:
                right_arrow = right_length + 1
            self.ans = max(self.ans, left_arrow + right_arrow)
            return max(left_arrow, right_arrow)

        arrow_length(root)
        return self.ans
```
- 时间复杂度：O(N)，其中 N 是树中节点数。我们处理每个节点一次。

- 空间复杂度：O(H)，其中 H 是树的高度。我们的递归调用栈可以达到 H 层的深度。
# 13. 间隔遍历
337. House Robber III (Medium)

小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
示例1：
```
输入: [3,2,3,null,3,null,1]

    *3*
    / \
   2   3
    \   \ 
    *3* *1*

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```
示例2：
```
输入: [3,4,5,1,3,null,1]

     3
    / \
  *4* *5*
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```
## 思路 待解决 动态规划
1. 如果父节点选择偷，那么本节点只能选择不偷
2. 如果父节点选择不偷，那么本节点可以选择偷
3. 如果父节点选择不偷，那么本节点依旧可以选择不偷
### 代码
```
class Solution(object):
    def rob(self, root):
        if not root:
            return 0
        def dfs(root,status):
            if not root:
                return 0
            a,b,c = 0,0,0
            # 不管父节点选择偷/不偷，本次什么都不干
            a = dfs(root.left,status)+dfs(root.right,status)
            # 父节点选择偷，本次不偷 
            if status:
                b = dfs(root.left,0)+dfs(root.right,0)
            # 父节点选择不偷，本次选择偷                
            else:
                c = dfs(root.left,1)+dfs(root.right,1)+root.val
            # 返回三种状态的最大值    
            return max(a,b,c)
        return dfs(root,0)
```
### 动态+递归
```
class Solution:
    def rob(self, root: TreeNode) -> int:
        if not root:
            return 0

        # 抽象到最小结构 动态规划结合递归， [3,2,3,null,3,null,1]为例
        # 递归到第二层2时 （不抢收益是3， 抢收益是2）;递归到第二层3时（不抢收益是1，抢收益是3）
        # 此时如何倒推到根节点是关键
        # 一般会想max(左抢+右抢， 抢根节点+左不抢+右不抢)是根节点的最优值 按照这个思路写会有一个问题
        # 就是 4 3 2 1这中情况不对，这是个思维陷阱：
        # res4= (0, 4)  res3=(4, 3) 这里在算res2不抢的时候，如果只是从res3抢继承过来就会导致错过4这个最优解
        # 所以我们修改max(左抢+右抢， 抢根节点+左不抢+右不抢) 为 max(max(左不抢+右抢, 左抢+右不抢， 左不抢+右不抢， 
        #左抢+右抢)， 抢根节点+左不抢+右不抢) 等价为 max(max(左不抢,左抢)+max(右不抢，右抢)， 抢根节点+左不抢+右不抢)
        def func(root):
            # 终止条件
            if not root:
                return 0, 0

            # 递归调用
            left_not_do, left_do = func(root.left)
            right_not_do, right_do = func(root.right)

            # 本次函数返回什么
            return max(left_not_do, left_do)+max(right_not_do, right_do), left_not_do+right_not_do+root.val

        return max(func(root))
```
# 14. 找出二叉树中第二小的节点
671. Second Minimum Node In a Binary Tree (Easy)

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1。

示例1：
```
输入: 
    2
   / \
  2   5
     / \
    5   7

输出: 5
说明: 最小的值是 2 ，第二小的值是 5 。
```
示例2：
```
输入: 
    2
   / \
  2   2

输出: -1
说明: 最小的值是 2, 但是不存在第二小的值。
```
## 思路
- 终止条件：节点为空
- 返回值：-1或者第二小的值
- 本次递归：遍历左右节点并与根节点的值比较，将第2小的值存放到res[0]
- 题解：https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/discuss/107165/Python-Extremely-Easy-To-Understand-(Beats-91)
### 代码
```
        res = [float('inf')]
        def traverse(node):
            if not node:
                return 
            if root.val < node.val < res[0]:
                res[0] = node.val
            traverse(node.left)
            traverse(node.right)
        traverse(root)
        return -1 if res[0] == float('inf') else res[0]
```



