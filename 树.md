# 递归
一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。

## 递归三部曲
1. 找整个递归的终止条件：递归应该在什么时候结束？
2. 找返回值：应该给上一级返回什么信息？
3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？
- 不必纠结这一层函数做了什么，下一层函数做了什么，只需关注一级递归的解决过程即可。
## 1. 树的高度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。
### 思路
力扣官方题解 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode/
### 代码
```
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1 
```
复杂度分析

- 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)O(N)，
其中 NN 是结点的数量。
- 空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 NN 次（树的高度），因此保持调用栈的存储将是 O(N)O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 \log(N)log(N)。因此，在这种情况下的空间复杂度将是 O(\log(N))O(log(N))。
## 2. 平衡树
110. Balanced Binary Tree (Easy)
    
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]
```
    3
   / \
  9  20
    /  \
   15   7
```
返回true

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]
```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回false
### 思路
从底至顶（提前阻断）
此方法为本题的最优解法，但“从底至顶”的思路不易第一时间想到。

思路是对二叉树做先序遍历，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。

从顶至底（暴力法）
此方法容易想到，但会产生大量重复计算，时间复杂度较高。
### 算法流程
isBalanced(root) ：判断树 root 是否平衡
- 特例处理： 若树根节点 root 为空，则直接返回 true；
- 返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑&& 连接；
### 复杂度分析
- 时间复杂度 O(Nlog2 N)： 最差情况下，isBalanced(root) 遍历树所有节点，占用 O(N)；判断每个节点的最大高度 depth(root) 需要遍历 各子树的所有节点，子树的节点数的复杂度为O(log2 N)。
- 空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。
### 暴力法代码
```
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        return abs(self.height(root.left) - self.height(root.right)) < 2 \
            and self.isBalanced(root.left) \
            and self.isBalanced(root.right)
    def height(self, root: TreeNode) -> int:
        if not root:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))
```
# 3. 两节点的最长路径
543. 二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树
```
          1
         / \
        2   3
       / \     
      4   5   
```
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
## 思路
- 重点是任意一个结点，都要记录以此结点为根的直径情况：左子树高度+右子树高度
- 需要一个值来保存我这个每次比较更新的最大直径值，用self.ans = 1来初始化这个值
- 在每次获得一个节点的左子树和右子树的值的时候，都需要比较一下self.ans和左子树高度+右子树高度的大小减1，把更大的保存下来
###代码
```
    self.ans = 1
    def depth(node):
        if not node:
            # 访问到空节点了，返回0
            return 0
            # 左儿子为根的子树的深度
        L = depth(node.left)
        # 右儿子为根的子树的深度
        R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
        self.ans = max(self.ans, L + R + 1)
        # 返回该节点为根的子树的深度
        return max(L, R) + 1
    depth(root)
    return self.ans -1
```
# 4.翻转树
226. Invert Binary Tree (Easy)

示例：

输入：
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
输出：
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
## 思路
- 终止条件：节点为空
- 返回值：当前节点以及它的左右子树
- 本级递归：交换左右子树
  
题解：https://leetcode-cn.com/problems/invert-binary-tree/solution/dong-hua-yan-shi-liang-chong-shi-xian-226-fan-zhua/

代码
```
class Solution(object):
    def invertTree(self, root):
    #函数递归终止条件，节点为空时返回
        if not root:
            return None:
        # 将当前节点的左右子树交换
        root.left, root.right = root.right, root.left
        # 递归交换当前节点的 左子树和右子树
        self.invertTree(root.left)
        self.invertTree(root.right)
        # 函数返回时就表示当前这个节点，以及它的左右子树
		# 都已经交换完了
        retrun root
```
- 时间复杂度：每个元素都必须访问一次，所以是O(n)
- 空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)
# 5. 归并两棵树
617. Merge Two Binary Trees (Easy)


给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例：
```
输入: 
	Tree 1                     Tree 2                  
          1                         2                 
         / \                       / \    
        3   2                     1   3
       /                           \   \
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```
## 思路
题解：https://leetcode-cn.com/problems/merge-two-binary-trees/solution/dong-hua-yan-shi-di-gui-die-dai-617he-bing-er-cha-/
- 终止条件：树1的节点为null，或者树2的节点为null
- 返回值：t1, t2
- 本级递归：r1 + r2
### 代码
```
class Solution(object):
	def mergeTrees(self, t1, t2):
        def dfs(r1, r2):
        # 如果 r1和r2中，只要有一个是null，函数就直接返回
            if not (r1 and r2):
                return r1 if r1 else r2
            # 让r1的值 等于  r1和r2的值累加
            # 再递归的计算两颗树的左节点、右节点
            r1.val += r2.val
            r1.left = dfs(r1.left, r2.left)
            r1.right = dfs(r1.right, r2.right)
            return r1
        return dfs(t1, t2)
```
- 时间复杂度：O(N)，其中 N 是两棵树中节点个数的较小值。
- 空间复杂度：O(N)，在最坏情况下，会递归 N 层，需要 O(N) 的栈空间。
  

# 6. 判断路径和是否等于一个数
Leetcdoe : 112. Path Sum (Easy)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
## 思路
- 终止条件：到达叶子节点
- 返回值：True或者False
- 本级递归：sum - 当前节点权值，判断是否为0
### 代码
```
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        #sum减去当前节点的值
        sum -= root.val
        #若到达叶子节点判断sum是否为0
        if not root.left and not root.right:
            return sum == 0
        #递归调用函数
        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)
```
- 时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。
- 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N 次（树的高度），因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。
# 7. 统计路径和等于一个数的路径数量
437. Path Sum III (Easy)
    
给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

示例
```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```
## 思路
- 终止条件：节点为空
- 返回值：路径数目
- 本级递归：求路径的和
- 题解：https://leetcode-cn.com/problems/path-sum-iii/solution/hot-100-437lu-jing-zong-he-iii-python3-li-jie-di-g/
### 代码 不懂
```
        prefixSumTree = {0:1}
        self.count = 0
        
        prefixSum = 0
        self.dfs(root, sum, prefixSum, prefixSumTree)
        
        return self.count
        
        
    def dfs(self, root, sum, prefixSum, prefixSumTree):
        if not root:
            return 0
        prefixSum += root.val
        oldSum = prefixSum - sum
        if oldSum in prefixSumTree:
            self.count += prefixSumTree[oldSum]
        prefixSumTree[prefixSum] = prefixSumTree.get(prefixSum, 0) + 1
        
        self.dfs(root.left, sum, prefixSum, prefixSumTree)
        self.dfs(root.right, sum, prefixSum, prefixSumTree)
        
        '''一定要注意在递归回到上一层的时候要把当前层的prefixSum的个数-1，类似回溯，要把条件重置'''
        prefixSumTree[prefixSum] -= 1
```
# 8.子树
572. Subtree of Another Tree (Easy)
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:
```
     3
    / \
   4   5
  / \
 1   2
```
给定的树 t：
```
   4 
  / \
 1   2
```
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：
```
     3
    / \
   4   5
  / \
 1   2
    /
   0
```
给定的树 t：
```
   4
  / \
 1   2
```
## 解题思路
- 终止条件：
- 返回值：True或者False
- 本级递归:t是否和树s的任意子树相等
- 题解：https://leetcode-cn.com/problems/subtree-of-another-tree/solution/dui-cheng-mei-pan-duan-zi-shu-vs-pan-duan-xiang-de/
 
要判断一个树 t 是不是树 s 的子树，那么可以判断 t 是否和树 s 的任意子树相等。那么就转化成 100. Same Tree。
即，这个题的做法就是在 s 的每个子节点上，判断该子节点是否和 t 相等。

判断两个树是否相等的三个条件是与的关系，即：

1. 当前两个树的根节点值相等；
2. 并且，s 的左子树和 t 的左子树相等；
3. 并且，s 的右子树和 t 的右子树相等。

而判断 t 是否为 s 的子树的三个条件是或的关系，即：

1. 当前两棵树相等；
2. 或者，t 是 s 的左子树；
3. 或者，t 是 s 的右子树。

### 代码
```
class Solution(object):
    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s and not t:
            return True
        if not s or not t:
            return False
        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
        
    def isSameTree(self, s, t):
        if not s and not t:
            return True
        if not s or not t:
            return False
        #为什么去掉s.val就不能通过所有测试用例呢
        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)
```

  



