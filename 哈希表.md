## 1.1 数组中两个数的和为给定值
1. Two Sum (Easy)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
### 思路 1
- 遍历每个数，循环中再遍历数组寻找对应值。时间复杂度为O(n^2)
### 思路 2
- 遍历每个数，看目标值 - 当前值是否存在哈希表中
- 数值作为键存储到哈希表，索引作为值存储
- 若存在，返回对应索引

### 代码
```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i, num in enumerate(nums):
            tep = target - nums[i]
            if tep in dic:
                return [dic[tep], i]
            #字典扩充要放到后面，防止[3,2,4]输出[0,0]
            dic[num] = i
        return []
```
- 时间复杂度：O(n) 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。

- 空间复杂度：O(n) 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。

## 1.2三数之和
15. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例
```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
### 思路
- 此问题的关键在于去重，可先将数组排序
- 遍历数组，设置左右指针分别指向遍历位置的下一位和最后一位
- 若遍历的数和前一个数相等，执行下一次循环，去重
- 判断 sume =  nums[i] + nums[L] + nums[R] 和 0 的关系
- 若sume = 0，res.append([nums[i], nums[L], nums[R])（1）L指针的数和下一个数相等，L = L + 1.（2）R指针的数和前一个数相等，R = R - 1.若不满足1 和 2，L = L + 1, R = R + 1
- 若sume > 0, R =  R - 1
- 若sume < 0, L = L + 1
- 返回res

### 代码
```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if not nums or n < 3:
            return []
        nums.sort()
        i= 0
        tem = []
        res = []
        #此处本来用的while循环，因为考虑到nums[i] == nums[i - 1]
        时 i += 1,不了解for 循环中可以用continue语句跳出本次循环
        for i in range(n - 2):
            if nums[i] > 0:
                break
            #要加i > 0, 否则[0, 0, 0]不通过
            if (i > 0 and nums[i] == nums[i - 1]):
                continue
            L = i + 1
            R = n - 1
            
            while L < R:
                sume =  nums[i] + nums[L] + nums[R]
                if sume == 0:
                    tem = [nums[i], nums[L], nums[R]]
                    res.append(tem)
                    while (L < R and nums[L] == nums[L + 1]):
                        L += 1
                    while (L < R and nums[R] == nums[R - 1]):
                        R -= 1
                    L += 1
                    R -= 1 
                elif sume < 0:
                    L = L + 1
                elif sume > 0:
                    R = R - 1
        return res
```
- 时间复杂度：O(N^2) 其中 N 是数组 nums 的长度。

空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(logN)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(N)。 

## 2. 判断数组是否含有重复元素
217. Contains Duplicate (Easy)

给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

示例 1:
```
输入: [1,2,3,1]
输出: true
```
示例 2:
```
输入: [1,2,3,4]
输出: false
```
### 思路
- 将遍历的数存到数组中时有测试用例超时
- 遍历数组，若当前数字在字典中，返回True
- 扩充字典，数值作为键，索引作为值

### 代码
```
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return True
            dic[num] = i
        return False
```
- 时间复杂度 O(n) 遍历数组所需时间
- 空间复杂度，O(n) 字典存储空间