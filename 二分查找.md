## 模板
```
def binary_search(l, r):
    while l < r:
         m = l + (r - 1) // 2 #防止边界溢出
         if f(m)： return m #可选择
         if g(m):  #如果查找到的值大于目标值
            r = m  #new range[l, m)
        else:
            l = m + 1 #new range[m + 1, r)
        return -1 #找到最小的 l 满足g(m) 或者未找到
```
例子 A = [1, 2, 2, 2, 4, 4, 5]

lower_bound(A, 2) = 1 lower_bound(A, 3) = 4 (does not exist)
upper_bound(A, 2) = 4 upper_bound(A, 5) = 7 (dose not exist)
```
#找到等于目标值索引并返回，有多个相等目标值返回最左边。
def lower_bound(A, val, l, r):
    while l < r:
        m = l + (r - l) // 2
        if A[m] >= val:
            r = m
        else:
            l = m + 1
    return l
```
```
#找到目标值索引的下一位并返回
def lower_bound(A, val, l, r):
    while l < r:
        m = l + (r - l) // 2
        if A[m] > val: #此处和上面不同
            r = m
        else:
            l = m + 1
    return l
```
## 1. 求开方
69. Sqrt(x) (Easy)

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例1：
```
输入: 4
输出: 2
```
示例2：
```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```
### 思路
二分查找，前闭后开
```
class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        #下边加 1 是为了保证 0 和 1 的正确性，加2，3，4等都可以。
        r = x + 1
        while l < r:
            m = l + (r - l) // 2
            if m ** 2 > x:
                r = m
            else:
                l = m + 1
        return  l - 1
```
时间复杂度：O(logx)，即为二分查找需要的次数。

空间复杂度：O(1)。