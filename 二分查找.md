- 题解：https://www.youtube.com/watch?v=v57lNF2mb_s
## 模板
```
def binary_search(l, r):
    while l < r:
         m = l + (r - 1) // 2 #防止边界溢出
         if f(m)： return m #可选择
         if g(m):  #如果查找到的值大于目标值
            r = m  #new range[l, m)
        else:
            l = m + 1 #new range[m + 1, r)
        return -1 #找到最小的 l 满足g(m) 或者未找到
```
例子 A = [1, 2, 2, 2, 4, 4, 5]

lower_bound(A, 2) = 1 lower_bound(A, 3) = 4 (does not exist)

upper_bound(A, 2) = 4 upper_bound(A, 5) = 7 (dose not exist)
### 模板 1
```
#找到等于目标值索引并返回，有多个相等目标值返回最左边。
def lower_bound(A, val, l, r):
    while l < r:
        m = l + (r - l) // 2
        if A[m] >= val:
            r = m
        else:
            l = m + 1
    return l
```
### 模板 2
```
#找到目标值索引的下一位并返回
def lower_bound(A, val, l, r):
    while l < r:
        m = l + (r - l) // 2
        if A[m] > val: #此处和上面不同
            r = m
        else:
            l = m + 1
    return l
```
## 1. 求开方
69. Sqrt(x) (Easy)

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例1：
```
输入: 4
输出: 2
```
示例2：
```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```
### 思路
二分查找，前闭后开
```
若用第一个模板，平方根为整数的可以找到，不为整数的会找到比小数大的第一个整数，若输入 8， 会找到 3。
class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        #下边加 1 是为了保证 0 和 1 的正确性，就此题而言，因为
        不存在数组索引 nums[m] 不存在，加2，3，4等都可以。
        r = x + 1
        while l < r:
            m = l + (r - l) // 2
            if m ** 2 > x:
                r = m
            else:
                l = m + 1
        return  l - 1
```
时间复杂度：O(logx)，即为二分查找需要的次数。

空间复杂度：O(1)。
## 4. 第一个错误的版本
278. First Bad Version (Easy)

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例：
```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 
```
### 思路
二分查找，不多BB，套模板
### 代码
```
#版本错误的排在后面，找最后正确版本的下一个，用模板 2。若找最后的正确版本，用模板 1。
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        l = 1
        r = n
        while l < r:
            m = l + (r - l) // 2
            if isBadVersion(m):
                r = m
            else:
                l = m + 1
        return l
```