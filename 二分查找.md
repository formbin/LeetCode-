- 题解：https://www.youtube.com/watch?v=v57lNF2mb_s
## 模板
```
def binary_search(l, r):
    while l < r:
         m = l + (r - 1) // 2 #防止边界溢出
         if f(m)： return m #可选择
         if g(m):  #如果查找到的值大于目标值
            r = m  #new range[l, m)
        else:
            l = m + 1 #new range[m + 1, r)
        return -1 #找到最小的 l 满足g(m) 或者未找到
```
例子 A = [1, 2, 2, 2, 4, 4, 5]

lower_bound(A, 2) = 1 lower_bound(A, 3) = 4 (does not exist)

upper_bound(A, 2) = 4 upper_bound(A, 5) = 7 (dose not exist)
### 模板 1
```
#找到等于目标值索引并返回，有多个相等目标值返回最左边。
def lower_bound(A, val, l, r):
    while l < r:
        m = l + (r - l) // 2
        if A[m] >= val:
            r = m
        else:
            l = m + 1
    return l
```
### 模板 2
```
#找到目标值索引的下一位并返回
def lower_bound(A, val, l, r):
    while l < r:
        m = l + (r - l) // 2
        if A[m] > val: #此处和上面不同
            r = m
        else:
            l = m + 1
    return l
```
## 1. 求开方
69. Sqrt(x) (Easy)

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例1：
```
输入: 4
输出: 2
```
示例2：
```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```
### 思路
二分查找，前闭后开
```
若用第一个模板，平方根为整数的可以找到，不为整数的会找到比小数大的第一个整数，若输入 8， 会找到 3。
class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        #下边加 1 是为了保证 0 和 1 的正确性，就此题而言，因为
        不存在数组索引 nums[m] 不存在，加2，3，4等都可以。
        r = x + 1
        while l < r:
            m = l + (r - l) // 2
            if m ** 2 > x:
                r = m
            else:
                l = m + 1
        return  l - 1
```
时间复杂度：O(logx)，即为二分查找需要的次数。

空间复杂度：O(1)。
## 2. 大于给定元素的最小元素
744. Find Smallest Letter Greater Than Target (Easy)

给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。

在比较时，字母是依序循环出现的。举个例子：

如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'

示例：
```
输入:
letters = ["c", "f", "j"]
target = "a"
输出: "c"

输入:
letters = ["c", "f", "j"]
target = "c"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "d"
输出: "f"

输入:
letters = ["c", "f", "j"]
target = "j"
输出: "c"
```
### 思路
-  二分查找，注意给出 target 若为列表末尾，r 若设为列表长度减1，
  l 最大为 r，会导致返回字母还是本身，可将r + 1解决此问题。

### 代码
```
class Solution:
    def nextGreatestLetter(self, letters: List[str],
     target: str) -> str:
        l = 0
        r = len(letters)
        while l < r:
            m = l + (r - l) //2
            #注意字母是可以直接比较大小的
            if letters[m] > target:
                r = m
            else:
                l = m + 1
        if l > (len(letters) - 1):
            return letters[0]
        return letters[l]
```
- 时间复杂度：O(logN)。N 指的是 letters 的长度，我们只查看数组中的 logn 个元素。
- 空间复杂度：O(1)。只使用了指针。

## 4. 第一个错误的版本
278. First Bad Version (Easy)

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例：
```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 
```
### 思路
二分查找，不多BB，套模板
### 代码
```
#版本错误的排在后面，找最后正确版本的下一个，用模板 2。若找最后的正确版本，用模板 1。
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        l = 1
        r = n
        while l < r:
            m = l + (r - l) // 2
            if isBadVersion(m):
                r = m
            else:
                l = m + 1
        return l
```