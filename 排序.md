### 快速排序代码
```
def quick_sort(lists, left, right):
    '''快速排序'''
    # 跳出递归判断
    if left >= right:
        return lists
 
    # 选择参考点，该调整范围的第1个值
    key = lists[left]
    low = left  
    high = right
 
    # 循环判断直到遍历全部
    while left < right:
        # 从右边开始查找大于参考点的值
        while left < right and lists[right] >= key:
            right -= 1
        lists[left] = lists[right]  # 这个位置的值先挪到左边
 
        # 从左边开始查找小于参考点的值
        while left < right and lists[left] <= key:
            left += 1
        lists[right] = lists[left]  # 这个位置的值挪到右边
 
    # 写回改成的值
    lists[left] = key
 
    # 递归，并返回结果
    quick_sort(lists, low, left - 1)    # 递归左边部分
    quick_sort(lists, left + 1, high)   # 递归右边部分
    return lists
lists = [3,5,7,9,0,8,6,2,1,4]
sort_lists = quick_sort(lists[:], 0, len(lists)-1)  #快速排序
print(sort_lists)
```

# 桶排序
## 1.出现频率最多的K个元素
347. Top K Frequent Elements (Medium)

示例1：
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```
示例2：
```
输入: nums = [1], k = 1
输出: [1]
```
提示：
- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
- 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
- 你可以按任意顺序返回答案。

设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。

把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。
## 2. 按照字符出现次数对字符串排序
451. 根据字符出现频率排序 (Medium)

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
```
输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```
### 代码
```
class Solution:
    def frequencySort(self, s: str) -> str:
        # 桶排序
        ret = []
        countFrequency = collections.defaultdict(int)
        for i in s:
            countFrequency[i] += 1
        buckets = [[] for _ in range(len(s) + 1)]
        for i in countFrequency:
            buckets[countFrequency[i]].extend(i*countFrequency[i])
        for i in buckets[::-1]:
            if(i):
                ret.extend(i)
        return ''.join(ret)
```


# 荷兰国旗问题
荷兰国旗包含三种颜色：红、白、蓝。

有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。
## 1.按颜色进行排序
1.  Sort Colors (Medium)

```
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```
题目描述：只有 0/1/2 三种颜色。
```
class Solution(object):
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        # 定义三个变量，p0表示数组最左边，0的区域，p2是数组最右边2的区域
        # 如果当前指向的是0，就把这个元素交换到数组左边
        # 也就是跟p0指针交换，之后cur，p0就往前一动一位
        # 如果当前指向的是2，就把这个元素交换到数组右边
        # 也就是跟p2指针交换，注意此时cur指针就不用移动了
        # 因为右边的一片区域都是2，只要把元素交换过去就可以了，cur不用移动
        # 如果是1的话，就不用交换
        if not nums or len(nums) == 0:
            return
        p0, cur, p2 = 0, 0, len(nums) - 1
        while cur <= p2:
            if nums[cur] == 0:
                nums[cur], nums[p0] = nums[p0], nums[cur]
                p0 += 1
                cur += 1
            elif nums[cur] == 2:
                nums[cur], nums[p2] = nums[p2], nums[cur]
                p2 -= 1
            else:
                cur += 1
```