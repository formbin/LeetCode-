## 1. 找出两个链表的交点
160. Intersection of Two Linked Lists (Easy)

编写一个程序，找到两个单链表相交的起始节点。

示例1：
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，
链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
示例2：
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，
所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```
### 思路
分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历。判断遍历过程中是否有节点相等，若有，返回该点。
### 代码
```
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        curA = headA
        curB = headB
        if not curA or not curB:
            return None
        while curA != curB:
            if curA:
                curA = curA.next
            else:
                curA = headB
            if curB:
                curB = curB.next
            else:
                curB = headA
        return curA
```
- 时间复杂度 : O(m+n)。
- 空间复杂度 : O(1)。
## 2. 链表反转
206. Reverse Linked List (Easy)

反转一个单链表。

示例
```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
### 思路
#### 双指针迭代
1. 我们可以申请两个指针，第一个指针叫 pre，最初是指向 None 的。
2. 第二个指针 cur 指向 head，然后不断遍历 cur。
3. 每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
4. 都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。
### 代码
```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 申请两个节点，pre和 cur，pre指向None
        cur = head
        pre = None
        # 遍历链表
        while cur:
            # 记录当前节点的下一个节点
            temp = cur.next
            # 然后将当前节点指向pre
            cur.next = pre
            # pre和cur节点都前进一位
            pre = cur
            cur = temp
        return pre
```
- 时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。
- 空间复杂度：O(1)。
#### 递归
- 整体思路
  1. 假设链表头节点N(1)后边已经反转完成，我们希望N(2)指向N(1)
  2. N(1)为链表末尾，切断原先的 N(1) -> N(2), 并指向空节点

- 细节思路（可不了解也能写出程序）
  1. 假设链表为 1 -> 2 -> 3 -> 4 -> 5
  2. 最后一个reverseList(5)来看返回了5这个节点
  3. reverseList(4)中
  4. cur为5
  5. head.next.next = head 相当于 5 -> 4
  6. 现在的节点情况为 4 -> 5 -> 4
  7. head.next = null,切断 4 -> 5，变为 5 -> 4
  8. 返回（return）cur为5，5 -> 4
  9. 返回上一层reverseList(3)
  10. 处理完后返回的是4 -> 3 存疑 5 -> 4 -> 3
  11. 依次向上

### 代码
```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 递归终止条件是当前为空，或者下一个节点为空
        if not head or not head.next:
            return head
        # 这里的cur就是最后一个节点
        cur = self.reverseList(head.next)
        head.next.next = head
        # 防止链表循环，需要将head.next设置为空
        head.next = None
        # 每层递归函数都返回cur，也就是最后一个节点
        return cur
```
时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。
## 3. 归并两个有序的链表
21. Merge Two Sorted Lists (Easy)

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

示例
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
### 思路
1. 设置一个哨兵节点prehead，并维护一个 pre 指针。在其后添加节点。
2. l1 和 l2 的节点值进行比较，将值较小的节点插入到 pre 后，将小节点指针和 pre 后移一位实现遍历。直至一个链表遍历完。
3. 判断哪个链表没有遍历完，将没有遍历完的部分添加到 pre 后。
4. 返回哨兵节点的下一个节点。

### 代码
```
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        prehead = pre = ListNode(0)
        while l1 and l2:
            if l1.val <= l2.val:
                pre.next = l1
                l1 = l1.next
            else:
                pre.next = l2
                l2 = l2.next
            pre = pre.next
        if l1:
            pre.next = l1
        if l2:
            pre.next = l2
        return prehead.next
```
- 时间复杂度：O(n + m) ，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。

- 空间复杂度：O(1) 。我们只需要常数的空间存放若干变量。

## 4. 从有序链表中删除重复节点
83. Remove Duplicates from Sorted List (Easy)

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例1：
```
输入: 1->1->2
输出: 1->2
```

示例2：
```
输入: 1->1->2->3->3
输出: 1->2->3
```
### 思路
- 设置cur指针指向头节点
- 比较指针当前指向节点和下一节点值的大小，若不相等，指针后移一位，继续遍历。若相等，当前节点指向下下个节点。
- 遍历完成后返回头节点。

### 代码
```
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        cur = head
        #要保证 cur.next 不为空，否则cur.next.val会报错
        while cur and cur.next:
            if cur.val != cur.next.val:
                cur = cur.next
            else:
                cur.next = cur.next.next
                #开始多加了下边一条语句，导致3个
                节点的值相等的时候只能删除中间的节点。
                #cur = cur.next
        return head
```
- 时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。

- 空间复杂度：O(1)，没有使用额外的空间。

## 5. 删除链表的倒数第 n 个节点
19. Remove Nth Node From End of List (Medium)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例
```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
### 暴力法代码
```
#两次遍历
class Solution(object):
	def removeNthFromEnd(self, head, n):
		"""
		:type head: ListNode
		:type n: int
		:rtype: ListNode
		"""
		if not head or n<=0:
			return head
		# 增加一个特殊节点，方便边界处理
		p = ListNode(-1)
		p.next,a,b,k = head,p,p,0
		# 第一次遍历，计算链表总长度
		while a.next:
			a,k = a.next,k+1
		# 如果链表总长度小于n，那就直接返回
		if k<n:
			return head
		# 计算第二次遍历多少个节点
		num = k-n
		# 第二次遍历，找到要删除节点的前一个节点
		while num>0:
			b,num = b.next,num-1
		# 删除节点，并返回
		b.next = b.next.next
		return p.next
```
### 双指针代码
```
#一次遍历
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if not head or n < 0:
            return None
        p = ListNode(-1)
        p.next = head
        a = p
        b = p
        while n > 0:
            a = a.next
            n -= 1
        #为什么下边的条件可加可不加
        if not a:
            return head
        while a.next and b.next:
            a = a.next
            b = b.next
        b.next = b.next.next
        return p.next
```
## 8. 回文链表
234. Palindrome Linked List (Easy)

请判断一个链表是否为回文链表。

示例1：
```
输入: 1->2
输出: false
```

示例2：
```
输入: 1->2->2->1
输出: true
```
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

### 思路 1
- 可考虑将链表的值遍历推入数组，比较反转后的数组和原数组是否相等。
### 代码
```
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if head is None:
            return True
        res = []
        cur = head
        while cur:
            res.append(cur.val)
            cur = cur.next
        return res == res[::-1]
```
- 时间复杂度：O(n)，其中 n 指的是链表的元素个数。
  - 第一步： 遍历链表并将值复制到数组中，O(n)。
  - 第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
  - 总的时间复杂度：O(2n)=O(n)。
- 空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。

### 思路 2
- 找到链表中间节点，将后半部分链表反转与之前的链表比较。
- 通过双指针遍历找到中间节点。
### 代码
```
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        slow = head
        fast = head
        # 找到中间节点
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        # 翻转后半部分
        pre = None    
        while slow:
            cur = slow.next
            slow.next = pre
            pre = slow
            slow = cur
        # 比较前后两部分
        while pre:
            if pre.val == head.val:
                pre = pre.next
                head = head.next
            else:
                return False
        return True
```
- 时间复杂度：O(n)，其中 n 指的是链表的大小。
- 空间复杂度：O(1)，我们是一个接着一个的改变指针，我们在堆栈上的堆栈帧不超过 O(1)。
- 该方法的缺点是，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执执行过程中链表暂时断开。（本解法并未将链表合并，官方解析合并了）

最终状态例子
```
                       fast     tmp
           None        prev     slow
            ^           ^        ^
            |           |        |
1 --> 2 --> 3 <-- 2 <-- 1       None
```
```
                          tmp
                          slow    
           None  prev     fast
            ^     ^        ^
            |     |        |
1 --> 2 --> 2 <-- 1       None
```

## 10. 链表元素按奇偶聚集
328. Odd Even Linked List (Medium)

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例1：
```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```
示例2：
```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```
- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

### 思路
1. 头节点为奇数链表的头节点 curA = head
2. 头节点下一个为偶数链表的头节点，curB = head.next
3. 找出关系式，奇数节点的下下个为奇数节点，偶数节点的下下个为偶节点。
4. 将curA和curB头节点前进一位，遍历链表。
5. 将奇数链表的尾节点和偶数链表的头节点相连。
### 代码
```
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        curA = head
        curB_head = curB = head.next
        while curA.next and curB.next:
            curA.next = curA.next.next
            curB.next = curB.next.next
            curA = curA.next
            curB = curB.next
        curA.next = curB_head
        return head
```
- 时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。

- 空间复杂度： O(1) 。
