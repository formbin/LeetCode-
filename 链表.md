## 1. 找出两个链表的交点
160. Intersection of Two Linked Lists (Easy)

编写一个程序，找到两个单链表相交的起始节点。

示例1：
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
示例2：
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```
### 思路
分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历。判断遍历过程中是否有节点相等，若有，返回该点。
### 代码
```
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        curA = headA
        curB = headB
        if not curA or not curB:
            return None
        while curA != curB:
            if curA:
                curA = curA.next
            else:
                curA = headB
            if curB:
                curB = curB.next
            else:
                curB = headA
        return curA
```
- 时间复杂度 : O(m+n)。
- 空间复杂度 : O(1)。
## 2. 链表反转
1.   Reverse Linked List (Easy)

反转一个单链表。

示例
```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
### 思路
#### 双指针迭代
1. 我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。
2. 第二个指针 cur 指向 head，然后不断遍历 cur。
3. 每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
4. 都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。
### 代码
```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 申请两个节点，pre和 cur，pre指向None
        cur = head
        pre = None
        # 遍历链表
        while cur:
            # 记录当前节点的下一个节点
            temp = cur.next
            # 然后将当前节点指向pre
            cur.next = pre
            # pre和cur节点都前进一位
            pre = cur
            cur = temp
        return pre
```
- 时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。
- 空间复杂度：O(1)。
#### 递归
- 整体思路
  1. 假设链表头节点N(1)后边已经反转完成，我们希望N(2)指向N(1)
  2. N(1)为链表末尾，切断原先的 N(1) -> N(2), 并指向空节点

- 细节思路（可不了解也能写出程序）
  1. 假设链表为 1 -> 2 -> 3 -> 4 -> 5
  2. 最后一个reverseList(5)来看返回了5这个节点
  3. reverseList(4)中
  4. cur为5
  5. head.next.next = head 相当于 5 -> 4
  6. 现在的节点情况为 4 -> 5 -> 4
  7. head.next = null,切断 4 -> 5，变为 5 -> 4
  8. 返回（return）cur为5，5 -> 4
  9. 返回上一层reverseList(3)
  10. 处理完后返回的是4 -> 3 存疑 5 -> 4 -> 3
  11. 依次向上

### 代码
```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 递归终止条件是当前为空，或者下一个节点为空
        if not head or not head.next:
            return head
        # 这里的cur就是最后一个节点
        cur = self.reverseList(head.next)
        head.next.next = head
        # 防止链表循环，需要将head.next设置为空
        head.next = None
        # 每层递归函数都返回cur，也就是最后一个节点
        return cur
```
时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。
## 5. 删除链表的倒数第 n 个节点
1.  Remove Nth Node From End of List (Medium)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例
```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
### 暴力法代码
```
#两次遍历
class Solution(object):
	def removeNthFromEnd(self, head, n):
		"""
		:type head: ListNode
		:type n: int
		:rtype: ListNode
		"""
		if not head or n<=0:
			return head
		# 增加一个特殊节点，方便边界处理
		p = ListNode(-1)
		p.next,a,b,k = head,p,p,0
		# 第一次遍历，计算链表总长度
		while a.next:
			a,k = a.next,k+1
		# 如果链表总长度小于n，那就直接返回
		if k<n:
			return head
		# 计算第二次遍历多少个节点
		num = k-n
		# 第二次遍历，找到要删除节点的前一个节点
		while num>0:
			b,num = b.next,num-1
		# 删除节点，并返回
		b.next = b.next.next
		return p.next
```
### 双指针代码
```
#一次遍历
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if not head or n < 0:
            return None
        p = ListNode(-1)
        p.next = head
        a = p
        b = p
        while n > 0:
            a = a.next
            n -= 1
        #为什么下边的条件可加可不加
        if not a:
            return head
        while a.next and b.next:
            a = a.next
            b = b.next
        b.next = b.next.next
        return p.next
```