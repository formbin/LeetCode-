## 1. 找出两个链表的交点
160. Intersection of Two Linked Lists (Easy)

编写一个程序，找到两个单链表相交的起始节点。

示例1：
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，
链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
示例2：
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，
所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```
### 思路
分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历。判断遍历过程中是否有节点相等，若有，返回该点。
### 代码
```
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        curA = headA
        curB = headB
        if not curA or not curB:
            return None
        while curA != curB:
            if curA:
                curA = curA.next
            else:
                curA = headB
            if curB:
                curB = curB.next
            else:
                curB = headA
        return curA
```
- 时间复杂度 : O(m+n)。
- 空间复杂度 : O(1)。
## 2. 链表反转
206. Reverse Linked List (Easy)

反转一个单链表。

示例
```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
### 思路
#### 双指针迭代
1. 我们可以申请两个指针，第一个指针叫 pre，最初是指向 None 的。
2. 第二个指针 cur 指向 head，然后不断遍历 cur。
3. 每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
4. 都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。
### 代码
```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 申请两个节点，pre和 cur，pre指向None
        cur = head
        pre = None
        # 遍历链表
        while cur:
            # 记录当前节点的下一个节点
            temp = cur.next
            # 然后将当前节点指向pre
            cur.next = pre
            # pre和cur节点都前进一位
            pre = cur
            cur = temp
        return pre
```
- 时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。
- 空间复杂度：O(1)。
#### 递归
- 整体思路
  1. 假设链表头节点N(1)后边已经反转完成，我们希望N(2)指向N(1)
  2. N(1)为链表末尾，切断原先的 N(1) -> N(2), 并指向空节点

- 细节思路（可不了解也能写出程序）
  1. 假设链表为 1 -> 2 -> 3 -> 4 -> 5
  2. 最后一个reverseList(5)来看返回了5这个节点
  3. reverseList(4)中
  4. cur为5
  5. head.next.next = head 相当于 5 -> 4
  6. 现在的节点情况为 4 -> 5 -> 4
  7. head.next = null,切断 4 -> 5，变为 5 -> 4
  8. 返回（return）cur为5，5 -> 4
  9. 返回上一层reverseList(3)
  10. 处理完后返回的是4 -> 3 存疑 5 -> 4 -> 3
  11. 依次向上

### 代码
```
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # 递归终止条件是当前为空，或者下一个节点为空
        if not head or not head.next:
            return head
        # 这里的cur就是最后一个节点
        cur = self.reverseList(head.next)
        head.next.next = head
        # 防止链表循环，需要将head.next设置为空
        head.next = None
        # 每层递归函数都返回cur，也就是最后一个节点
        return cur
```
时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。
## 5. 删除链表的倒数第 n 个节点
1.  Remove Nth Node From End of List (Medium)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例
```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```
### 暴力法代码
```
#两次遍历
class Solution(object):
	def removeNthFromEnd(self, head, n):
		"""
		:type head: ListNode
		:type n: int
		:rtype: ListNode
		"""
		if not head or n<=0:
			return head
		# 增加一个特殊节点，方便边界处理
		p = ListNode(-1)
		p.next,a,b,k = head,p,p,0
		# 第一次遍历，计算链表总长度
		while a.next:
			a,k = a.next,k+1
		# 如果链表总长度小于n，那就直接返回
		if k<n:
			return head
		# 计算第二次遍历多少个节点
		num = k-n
		# 第二次遍历，找到要删除节点的前一个节点
		while num>0:
			b,num = b.next,num-1
		# 删除节点，并返回
		b.next = b.next.next
		return p.next
```
### 双指针代码
```
#一次遍历
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if not head or n < 0:
            return None
        p = ListNode(-1)
        p.next = head
        a = p
        b = p
        while n > 0:
            a = a.next
            n -= 1
        #为什么下边的条件可加可不加
        if not a:
            return head
        while a.next and b.next:
            a = a.next
            b = b.next
        b.next = b.next.next
        return p.next
```
## 8. 回文链表
234. Palindrome Linked List (Easy)

请判断一个链表是否为回文链表。

示例1：
```
输入: 1->2
输出: false
```

示例2：
```
输入: 1->2->2->1
输出: true
```
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

### 思路
- 可考虑将链表的值遍历推入数组，比较反转后的数组和原数组是否相等。
### 代码
```
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if head is None:
            return True
        res = []
        cur = head
        while cur:
            res.append(cur.val)
            cur = cur.next
        return res == res[::-1]
```
- 时间复杂度：O(n)，其中 n 指的是链表的元素个数。
  - 第一步： 遍历链表并将值复制到数组中，O(n)。
  - 第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
  - 总的时间复杂度：O(2n)=O(n)。
- 空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。



## 10. 链表元素按奇偶聚集
1.   Odd Even Linked List (Medium)

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例1：
```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```
示例2：
```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```
- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

### 思路
1. 头节点为奇数链表的头节点 curA = head
2. 头节点下一个为偶数链表的头节点，curB = head.next
3. 找出关系式，奇数节点的下下个为奇数节点，偶数节点的下下个为偶节点。
4. 将curA和curB头节点前进一位，遍历链表。
5. 将奇数链表的尾节点和偶数链表的头节点相连。
### 代码
```
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        curA = head
        curB_head = curB = head.next
        while curA.next and curB.next:
            curA.next = curA.next.next
            curB.next = curB.next.next
            curA = curA.next
            curB = curB.next
        curA.next = curB_head
        return head
```
- 时间复杂度： O(n) 。总共有 n 个节点，我们每个遍历一次。

- 空间复杂度： O(1) 。
