## 1. 把数组中的 0 移到末尾
283. Move Zeroes (Easy)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例：
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

### 思路
- 我们创建两个指针i和j，第一次遍历的时候指针j用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。
- 第二次遍历的时候，起始位置就从j开始到结束，将剩下的这段区域内的元素全部置为0。

### 代码
```
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i = 0
        j = 0
        while i < len(nums):
            if nums[i] != 0:
                nums[j] = nums[i]
                j += 1
            i += 1
        while j < len(nums):
            nums[j] = 0
            j += 1
        return nums 
```
- 时间复杂度:O(n)
- 空间复杂度:O(1)

## 2. 改变矩阵维度
566. Reshape the Matrix (Easy)

在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵.

示例1：
```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
```

示例2：
```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 2, c = 4
输出: 
[[1,2],
 [3,4]]
解释:
没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。
```
注意：
- 给定矩阵的宽和高范围在 [1, 100]。
- 给定的 r 和 c 都是正数。

### 思路
- 将矩阵转换为数组，再根据目标矩阵的列数进行切片。

### 代码
```
class Solution:
    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
        if len(nums) * len(nums[0]) != r * c:
            return nums
        else:
            origin = []
            for i in range(len(nums)):
                origin += nums[i]
            res = []
            for i in range(r):
                res.append(origin[i*c:i*c+c])
            return res
```
- 时间复杂度：O(m∗n)。我们只遍历整个矩阵 m∗n。这里，m 和 n 指的是给定矩阵中的行数和列数。

- 空间复杂度：O(m∗n)。使用大小为 m∗n 的结果矩阵。

## 3. 找出数组中最长的连续 1
485. Max Consecutive Ones (Easy)

给定一个二进制数组， 计算其中最大连续1的个数。

示例：
```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```
输入的数组只包含 0 和1。
输入数组的长度是正整数，且不超过 10,000。

### 思路
- 计数器 sum 初始化为 0，记录 1 的个数。遇到 1 加 1，遇到 0 重置为 0。
- 另一个计数器 maxsum 记录当前最大的 1 的个数。
- 返回maxsum。

### 代码
```
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        sum = 0
        maxsum = 0
        for num in nums:
            if num == 1:
                sum += 1
            else:
                maxsum = max(sum, maxsum)
                sum = 0
        #若都为1，则 sum 比 maxsum 大
        return max(sum, maxsum)
```
- 时间复杂度：O(N)。N 值得是数组的长度。
- 空间复杂度：O(1)，仅仅使用了 count 和 maxCount。



